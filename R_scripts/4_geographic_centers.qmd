---
title: "4_geographic_centers"
author: "Shayna A. Sura"
format: pdf
---



```{r setup}

library(tidyverse) # includes and loads the packages listed below
# library(readr)
# library(tidyr)
# library(dplyr)
# library(ggplot2)
# library(lubridate)

library(here) # helps with paths for files

library(purrr)

library(rvest) #for web scraping
library(xml2)
library(stringr)

```



```{r reading in cleaned bio data}
#| echo: false
#| message: false

bio_data_clean <- read_csv(file = "data/clean_data/bio_data.csv")

# head(bio_data_clean)

```


```{r lionfish data subset}

lionfish_data <- bio_data_clean %>% 
  filter(GENUS_BGS == "PTEROIS")

## need to add zeroes to the lionfish data for the years before it was detected and any years it wasn't detected when surveys were done.
survey_years <- data.frame("YR" = sort(unique(bio_data_clean$YR)))
# survey_years

## need to add zeroes to the lionfish data for the SURVEY STATIONS within each year where lionfish were NOT detected...


## Do a right join to the survey_years work for adding zeroes to the lionfish_data to get the animation to show the blank years.
# lionfish_data <- lionfish_data %>% 
#   right_join(survey_years, join_by(YR))

```



```{r calculate gCOB for lionfish}

# create an empty list to store cg dataframe
species_gCOBs <- list()

# create an empty data frame to store calculate gCOB values in
cg <- data.frame(year = unique(lionfish_data$YR),
                 latitude = NA,
                 longitude = NA)

# determine the unique years for which lionfish data exist
unique_years <- unique(lionfish_data$YR)


# for loop to calculate gCOB values for each year in which lionfish data exist
for(i in 1:length(unique(lionfish_data$YR))) {
  filtered_data <- filter(lionfish_data, YR == unique_years[i])
  
  # Check if the filtered dataset is not empty
  if(nrow(filtered_data) > 0) {
    cg$latitude[i] <- sum(filtered_data$DECSLAT * filtered_data$SELECT_BGS) / sum(filtered_data$SELECT_BGS)
    cg$longitude[i] <- sum(filtered_data$DECSLON * filtered_data$SELECT_BGS) / sum(filtered_data$SELECT_BGS)
  } else {
    # If the filtered dataset is empty, assign NA to latitude and longitude
    cg$latitude[i] <- NA
    cg$longitude[i] <- NA
  }
}

species_gCOBs[["lionfish_gCOB_test"]] <- cg

species_gCOBs[["lionfish_gCOB_test"]]

```



```{r function to calculate gCOB for species}

fish_calculate_gCOB <- function(data = bio_data_clean,
                                taxonomic_column = "new_TAXON",
                                # taxonomic_column = "TAXONOMIC",
                                common_name_column = "common_name",
                                species_name)
  {
  species_data <- data %>% 
    filter(if_any(all_of(taxonomic_column), ~ toupper(.) == toupper(species_name)))
  
  # Check if there is data for the specified species
  if (nrow(species_data) == 0) {
    stop(paste("No data found for species:", species_name))
  }
  
  # determine the specific years where fish appeared in trawl(s)
  unique_years <- unique(species_data$YR)

  # initate empty data frame to store data in
  cg <- data.frame(year = unique_years,
                   latitude = NA,
                   longitude = NA)

  # for loop to calculate gCOB latitude and longitude for each year when fish appeared in trawl(s)
  for(i in 1:length(unique_years)) {
    filtered_data <- filter(species_data, YR == unique_years[i])

    # Check if the filtered dataset is not empty
    if(nrow(filtered_data) > 0) {
      cg$latitude[i] <- sum(filtered_data$DECSLAT * filtered_data$SELECT_BGS) / sum(filtered_data$SELECT_BGS)
      cg$longitude[i] <- sum(filtered_data$DECSLON * filtered_data$SELECT_BGS) / sum(filtered_data$SELECT_BGS)
    } else {
      # If the filtered dataset is empty, assign NA to latitude and longitude
      cg$latitude[i] <- NA
      cg$longitude[i] <- NA
    }}

  # Order the cg dataframe by time / years
  cg <- cg %>% arrange(year)
  
  # Get the existing list from the global environment
  global_species_gCOBs <- get("species_gCOBs", envir = .GlobalEnv)  
  
  # Assign the cg dataframe with gCOB values the name of the fish species and add to the global_species_gCOBs list
  global_species_gCOBs[[paste(species_name, "_gCOB", sep = "")]] <- cg
  
  # Assign the modified list back to the global environment
  assign("species_gCOBs", global_species_gCOBs, envir = .GlobalEnv)  

  # # Assign the cg dataframe with gCOB values to a variable with a name that includes the species name
  # assign(paste(species_name, "_gCOB", sep = ""), cg, envir = .GlobalEnv)

  # Return the cg dataframe
  return(cg)
  
}


```




```{r testing the gCOB function with individual species}

## testing the function

fish_calculate_gCOB(bio_data_clean,
                    taxonomic = "GENUS_BGS",
                    species_name = "Pterois")


fish_calculate_gCOB(bio_data_clean,
                    taxonomic = "new_TAXON",
                    species_name = "Epinephelus morio")

```

## Import list of refined fish species taxonomic names from R script "3_species_info" to use here

```{r import list of refined fish species taxonomic names}

## TO DO ##


```




## Applying the gCOB function to all the unique fish species identified in the dataset

```{r appy gCOB function to each unique fish species - calculate gCOB for all fish species}

# create an empty list to store cg dataframes
species_gCOBs <- list()


# Apply the fish_calculate_gCOB function to each unique species and combine results into a list
result_list <- map(species_list, ~ fish_calculate_gCOB(taxonomic_column = "new_TAXON", species_name = .))

```


## Pulling results of calculated gCOBs for individual species from species_gCOBs list

```{r access gCOB values for individual species}

## pull results for individual species
# Convert the species names to lowercase for case-insensitive matching
species_name <- tolower("Epinephelus morio")
 # 	ALUTERUS SCHOEPFII

species_name <- tolower("ALUTERUS SCHOEPFII")

# Find the index corresponding to the species name (case-insensitive)
index <- which(grepl(species_name, tolower(names(species_gCOBs))))

if (length(index) == 0) {
  # If no match is found, print an error message
  print("Species not found in the result list.")
} else {
  # Access the result for the first matching species
  species_gCOBs[[index[1]]]
  # species_result <- species_gCOBs[[index[1]]]
}

# species_result



# Access the result for a specific species by its taxonomic name
# Convert the species names to lowercase for case-insensitive matching
species_name <- tolower("Epinephelus morio")

# Access the result for a specific species by its taxonomic name (case-insensitive)
species_result <- species_gCOBs[[which(tolower(names(species_gCOBs)) == species_name)]]

# Get the list of species names from the species_gCOBs list
# names(species_gCOBs)
species_names <- names(species_gCOBs)

```





```{r test for linear trends of gCOB for lionfish}

ggplot(cg, aes(longitude, latitude)) +
  geom_point(aes(colour = year))


ggplot(cg, aes(year, longitude)) +
  geom_point() +
  geom_smooth(method = lm,
              level = 0.95,
              col = "purple",
              linewidth = 2)


ggplot(cg, aes(year, latitude)) +
  geom_point() +
  geom_smooth(method = lm,
              level = 0.95,
              col = "purple",
              linewidth = 2)


lat_model <- lm(latitude ~ year, data = cg)
summary(lat_model)


long_model <- lm(longitude ~ year, data = cg)
summary(long_model)


```



```{r function run linear models in gCOB latitude and longitudes over time}

# initiate empty data frame to store data in
# gCOB_trends <- data.frame(species = NA,
#                           latitude_year_coef = NA,
#                           latitude_year_SE = NA,
#                           latitude_pvalue = NA,
#                           latitude_rsquared = NA,
#                           latitude_rsquared_adj = NA,
#                           longitude_year_coef = NA,
#                           longitude_year_SE = NA,
#                           longitude_pvalue = NA,
#                           longitude_rsquared = NA,
#                           longitude_rsquared_adj = NA)


# function to run linear models on gCOB latitude and longitude values over time to test for shifts
test_gCOBs_over_time <- function(species_name)
{
  species <- tolower(species_name)
  
  # Find the index corresponding to the species name (case-insensitive)
  index <- which(grepl(species, tolower(names(species_gCOBs))))
  
  if (length(index) == 0) {
    # If no match is found, print an error message
    print("Species not found in the species_gCOBs list.")
  } else {
    # Access the result for the first matching species
    species_result <- species_gCOBs[[index[1]]]
  }
  
  
  internal_gCOB_trends <- data.frame(species = NA,
                                     latitude_year_coef = NA,
                                     latitude_year_SE = NA,
                                     latitude_pvalue = NA,
                                     latitude_rsquared = NA,
                                     latitude_rsquared_adj = NA,
                                     longitude_year_coef = NA,
                                     longitude_year_SE = NA,
                                     longitude_pvalue = NA,
                                     longitude_rsquared = NA,
                                     longitude_rsquared_adj = NA)
  
  # put species name in first column
  internal_gCOB_trends$species <- toupper(species_name)
  
  
  # Check if there are any non-NA values in the data frame
  if (all(is.na(species_result$latitude)) || all(is.na(species_result$longitude))) {
    # If there are only NAs in the data frame, assign NA to all values
    internal_gCOB_trends$latitude_year_coef <- NA
    internal_gCOB_trends$latitude_year_SE <- NA
    internal_gCOB_trends$latitude_pvalue <- NA
    internal_gCOB_trends$latitude_rsquared <- NA
    internal_gCOB_trends$latitude_rsquared_adj <- NA
    internal_gCOB_trends$longitude_year_coef <-NA
    internal_gCOB_trends$longitude_year_SE <- NA
    internal_gCOB_trends$longitude_pvalue <- NA
    internal_gCOB_trends$longitude_rsquared <- NA
    internal_gCOB_trends$longitude_rsquared_adj <- NA
  } else {
  
    # fit linear models testing for trends in latitude and longitude of gCOBs over time
    lat_model <- lm(latitude ~ year, data = species_result)
    long_model <- lm(longitude ~ year, data = species_result)
    
    # Check if the models produced valid results
    if(is.na(coef(lat_model)[["year"]]) == TRUE) {
      # If the coefficient for the year predictor is NA (meaning only one data point), assign NA to all values
      internal_gCOB_trends$latitude_year_coef <- NA
      internal_gCOB_trends$latitude_year_SE <- NA
      internal_gCOB_trends$latitude_pvalue <- NA
      internal_gCOB_trends$latitude_rsquared <- NA
      internal_gCOB_trends$latitude_rsquared_adj <- NA
    } else {
      # Pull out important result values from the linear model summary
      internal_gCOB_trends$latitude_year_coef <- lat_model$coefficients[["year"]]
      internal_gCOB_trends$latitude_year_SE <- coef(summary(lat_model))[["year","Std. Error"]]
      internal_gCOB_trends$latitude_pvalue <- coef(summary(lat_model))["year", "Pr(>|t|)"]
      internal_gCOB_trends$latitude_rsquared <- summary(lat_model)$r.squared
      internal_gCOB_trends$latitude_rsquared_adj <- summary(lat_model)$adj.r.squared
    }
    
    if(is.na(coef(long_model)[["year"]]) == TRUE) {
      # If the coefficient for the year predictor is NA (meaning only one data point), assign NA to all values
      internal_gCOB_trends$longitude_year_coef <-NA
      internal_gCOB_trends$longitude_year_SE <- NA
      internal_gCOB_trends$longitude_pvalue <- NA
      internal_gCOB_trends$longitude_rsquared <- NA
      internal_gCOB_trends$longitude_rsquared_adj <- NA
    } else {
      # Pull out important result values from the linear model summary
      internal_gCOB_trends$longitude_year_coef <- long_model$coefficients[["year"]]
      internal_gCOB_trends$longitude_year_SE <- coef(summary(long_model))[["year","Std. Error"]]
      internal_gCOB_trends$longitude_pvalue <- coef(summary(long_model))["year", "Pr(>|t|)"]
      internal_gCOB_trends$longitude_rsquared <- summary(long_model)$r.squared
      internal_gCOB_trends$longitude_rsquared_adj <- summary(long_model)$adj.r.squared
    }
  }
  
  
  
  # Get the existing dataframe from the global environment
  global_gCOB_trends <- get("gCOB_trends", envir = .GlobalEnv)  
  
  # Assign the cg dataframe with gCOB values the name of the fish species and add to the global_gCOB_trends dataframe
  global_gCOB_trends <- rbind(global_gCOB_trends, internal_gCOB_trends)
  
  # Assign the modified dataframe back to the global environment
  assign("gCOB_trends", global_gCOB_trends, envir = .GlobalEnv)
  
  return(internal_gCOB_trends)
  
}


```


## Applying the gCOB trends function to all the unique fish species identified in the dataset

```{r appy test_gCOBs_over_time function to each unique fish species - test for trends in gCOBs for all species}

# initiate empty data frame to store data in
gCOB_trends <- data.frame(species = NA,
                          latitude_year_coef = NA,
                          latitude_year_SE = NA,
                          latitude_pvalue = NA,
                          latitude_rsquared = NA,
                          latitude_rsquared_adj = NA,
                          longitude_year_coef = NA,
                          longitude_year_SE = NA,
                          longitude_pvalue = NA,
                          longitude_rsquared = NA,
                          longitude_rsquared_adj = NA)


# Apply the test_gCOBs_over_time function to each unique species and combine results into a dataframe
individual_trends_results <- map(species_list, ~ test_gCOBs_over_time(species_name = .))

```


## NEXT - Summarize results from all the linear models...

- join the information about climate zone for the various fish species into the linear model results
- remove those fish species that don't have any or enough data for testing for linear trends over time
- group table by climate zone preferences
- explore results! ...how exactly?
  - start by examining frequency of latitude models with p-values < 0.05 indicating a significant trend over time
  - examine frequency of longitude models with p-values < 0.05 (indicating a significant trend over time)

- Latitude Meanings
  - positive coefficient estimate for latitude indicates...
  - negative coefficient estimate for latitude indicates...
- Longitude Meanings
  - positive coefficient estimate for longitude indicates...
  - negative coefficient estimate for longitude indicates...


```{r}


# 1. join climate zone information to gCOB_trends

climate_gCOB_trends <- gCOB_trends %>% 
  rename(species_name = species) %>% 
  left_join(species_climate_df, join_by(species_name))

# 2. remove fish species who cannot have trends examined over time

climate_gCOB_trends_slim <- climate_gCOB_trends %>% 
  filter(latitude_pvalue != "NA") %>% 
  filter(latitude_pvalue != "NaN")


# 3. group by climate zone information...






```

 
## Make figures to examine for trends

```{r}

```




